local table   = require('table')
local Object  = require('core').Object
local string  = require('string')
local math    = require('math')
local twisted = require('twisted')
local Array   = require('../base').Array
local utils   = require('../utils')
local yield   = twisted.yield

--[[--
	Functions contained within the promise namespace aids in writing lazily evaluated objects.
	Objects created by promises are usually bearers of certain conditions that allows object creation
	to be deferred until all of the pieces of the puzzle are present.

	@VOLATILE API, subjected to change so do not use unless necessary. These are useful for defining
	new field types for Rocket models.
--]]--

local promise = {} -- Namespace

--~ Developer's Note:
--~ The return values of any given promise is implemented as a callable userdata.
--~ The idea behind this is that userdata can be associated with a __gc metamethod
--~ to alert the model of its own garbage collection. This will probably change in the future.

--=--=--=--=--=--=--=--=--=--=--=--=--=--

--~ Promise.type returns a validator for a specific lua type. It also incorporates integers.
--~ @param _type in "string", "boolean", "table", "number", and "int"
--~ @param default is an instance of type '_type'
--~ @return callable that will return nil if the object passed in does not satisfy type condition
function promise.type(_type, default)
	local validator = newproxy(true)
	local mt = getmetatable(validator)
	function mt.__call(self,object)
		if object == nil then
			return default
		end
		if type(object) == _type or _type == "*" then
			return object
		elseif type(object) == "number" and _type == "int" then
			if object == math.floor(object) then return object end
		else
			return nil
		end
	end
	mt.__index = {default=default}
	return validator
end

--~ Promise.constant returns a validator that checks to see if an object == the constant
--~ @param constant is the constant that the validator checks against
--~ @return callable that will return nil if the object passed in does not equal the constant
function promise.constant(constant)
	local validator = newproxy(true)
	local mt = getmetatable(validator)
	function mt.__call(self,object)
		if object == constant then
			return object
		end
	end
	return validator
end

--~ Promise.field returns a field validator that checks if an evaluated field fulfills all of the promises.
--~ @param promises is a keyed table (hash if you will) of field flags versus a promise validator (see above two functions) that can be generated by promise.type or constant or even handwritten.
--~ @return callable that will evaluate a field object and return nil if the field does not satisfy any of the promises.
function promise.field(promises)
	--print(dump(promises))
	--VALIDATOR
	local validator = newproxy(true)
	local mt = getmetatable(validator)
	function mt.__call(self, object)
		if promises.default then
			if object == nil then return self(promises.default) end
		end
		if promises.null then
			if object == nil then return nil end
		else
			if object == nil then return nil end
		end
		if promises.promise then
			if promises.promise(object, promises) then
				return object
			else
				return nil
			end
		end

		return object
	end
	mt.__index = promises
	function mt.__index.params()
		return pairs(mt.__index)
	end
	function mt.__newindex(self, k, v)
		if k == "name" then mt.__index.name = v end
	end
	function mt.__tostring(self)
		return "<VALIDATOR>"
	end
	return validator
end

local Field__mt = {}

Field__mt.__index = {
	null 	= promise.type("boolean", false),
	default	= promise.type("*"),
	editable= promise.type("boolean", true),
	help	= promise.type("string", "Potions Field"),
	pk		= promise.type("boolean", false),
	unique	= promise.type("boolean", false),
	name	= promise.type("string"),
	type	= "Field",
}

local Field = {
	new = function(this, args)
		local mt = {}
		function mt.__newindex(self, key, val)
			self.addons[key] = val
		end
		function mt.__call(self, params)
			local seen = {}
			local promises = {promise = args.promise, type = args.type}

			params = params or {}

			for _,positional in ipairs(params) do
				seen[_] = true
				--pass
			end

			for key,var in pairs(params) do
				if not seen[key] then
					local _promise = self[key]
					if _promise then
						if _promise(var) ~= nil then
							promises[key] = _promise(var)
						else
							error "Wrong Type"
						end
					end
					if key:sub(1, 3) == "on_" or key == "serialize" or key == "deserialize" or name == "sql" then
						promises[key] = var
					end
					seen[key] = true
				end
			end

			for name,field in pairs(self.addons) do
				if not seen[name] then
					seen[name] = true
					if type(field) ~= "function" then
						if field.default then promises[name] = field.default end
					end
					if name:sub(1, 3) == "on_" or name == "serialize" or name == "deserialize" or name == "sql" then
						promises[name] = field
					end
				end
			end

			for name,field in pairs(self.index) do
				if not seen[name] then
					seen[name] = true
					if field.default then promises[name] = field.default end
				end
			end
			--print(dump(promises))
			return promise.field(promises)
		end
		function mt.__index(self, key)
			if key == "addons" then return rawget(self,"addons") end
			if key == "index" then return getmetatable(this).__index end
			local tab2 = getmetatable(this).__index
			local tab1 = rawget(self,"addons")
			if tab1[key] then return tab1[key] else return tab2[key] end
		end
		local field = {new=this.new, addons={}}
		setmetatable(field, mt)
		if args.promise then
			rawset(field, "promise", args.promise)
		end
		if args.serialize then
			rawset(field, "serialize", args.serialize)
			field.addons.serialize = args.serialize
		end
		if args.deserialize then
			rawset(field, "deserialize", args.deserialize)
			field.addons.deserialize = args.deserialize
		end
		if args.sql then
			rawset(field, "sql", args.sql)
			field.addons.sql = args.sql
		end
		for k,v in pairs(args) do if k ~= "promise" then field[k] = v end end
		return field
	end
}
setmetatable(Field, Field__mt)

local Mopee = Object:extend()

Mopee.IntegerField = Field:new{
	type	= "IntegerField",
	promise = promise.type("int"),
	default = promise.type("int"),

	deserialize = function(self, object, callable)
		return callable(tonumber(object))
	end,

	sql = function(self, field)
		local sql = self.field_name .. " INTEGER"
		if self.pk then
			sql = sql .. " PRIMARY KEY"
		end
		if self.unique then
			sql = sql .. " UNIQUE"
		end
		if not self.null then
			sql = sql .. " NOT NULL"
		end
		if self.default then
			sql = sql .. " DEFAULT " .. tostring(self.default)
		end
		return sql
	end
}

Mopee.CharField = Field:new{
	type 	= "CharField",
	promise = function(object, promises)
		local result = promise.type("string")(object)
		if not result then return result end
		if #result > promises.max_length then return nil end
		return result
	end,
	max_length = promise.type("int", 50),

	serialize = function(self, object, callable)
		return callable('"'..object:gsub('"','\\"')..'"')
	end,

	sql = function(self, field)
		local sql = self.field_name .. " VARCHAR("..tostring(self.max_length)..")"
		if self.unique then
			sql = sql .. " UNIQUE"
		end
		if not self.null then
			sql = sql .. " NOT NULL"
		end
		if self.default then
			sql = sql .. " DEFAULT " .. self:serialize(self.default)
		end
		return sql
	end
}



Mopee.BooleanField = Field:new{
	type	= "BooleanField",
	promise = promise.type("boolean"),
	default = promise.type("boolean"),

	serialize = function(self, object, callable)
		if object == true then
			return callable("TRUE")
		else
			return callable("FALSE")
		end
	end,
	deserialize = function(self, object, callback)
		if object:lower() == "true" then 
			return callback(true) 
		else 
			return callback(false) 
		end
	end,

	sql = function(self, field)
		local sql = self.field_name .. " BOOLEAN"
		if self.unique then
			sql = sql .. " UNIQUE"
		end
		if not self.null then
			sql = sql .. " NOT NULL"
		end
		if self.default then
			sql = sql .. " DEFAULT " .. self:serialize(self.default)
		end
		return sql
	end
}

Mopee.CommaSeparatedIntegerField = Field:new{
	type	= "CommaSeparatedIntegerField",
	max_length = promise.type("integer", 50),
	promise = function(object, promises)
		local result = promise.type("table")(object)
		if not result then return nil end
		if #result > promises.max_length then return nil end
		for _,v in ipairs(object) do
			if not promise.type("int")(v) then return nil end
		end
		return result
	end,
	serialize = function(self,object)
		return table.concat(object, ";")
	end,
	deserialize = function(self,str)
		local stack = {}
		for w in string.gmatch(str, "[^;]+") do table.insert(stack, w) end
		return stack
	end,

	sql = function(self, field)
		local sql = self.field_name .. " VARCHAR("..tostring(self.max_length*5)..")"
		if self.unique then
			sql = sql .. " UNIQUE"
		end
		if not self.null then
			sql = sql .. " NOT NULL"
		end
		if self.default then
			sql = sql .. " DEFAULT " .. self:serialize(self.default)
		end
		return sql
	end
}

Mopee.ForeignKey = Field:new{
	type	= "ForeignKey",
	to		= promise.type("*"),
	promise = function(object, promises)
		local ref
		if type(promises.to) == "string" then
			if promises.to:sub(#(promises.to)-6) ~= "_model" then
				ref = promises.to .. "_model"
			else
				ref = promises.to
			end
			if model.static[ref] then
				promises.to = model.static[ref]
			else
				return nil
			end
		end

		if type(object) ~= "table" then return nil end
		if not object.super then return nil end

		if object.super.model_name ~= promises.to.model_name then
			return nil
		end
		return object
	end,

	serialize = function(self, object)
		return tostring(object.id)
	end,
	deserialize = function(self,str)
		local id = tonumber(str)
		local object = self.to
		if type(object) == "string" then
			object = model.static[object.."_model"]
		end
		return object.objects.get{id=id}
	end,

	on_save = function(self, this)
		if not self[this].id then
			self[this]:save()
		end
	end,
	on_create = function(self, this)
		local object = self.to
		if type(object) == "string" then
			if object:sub(#object-4) ~= "_model" then
				object = object.."_model"
			end
		elseif type(object) == "table" then
			object = object.table
		end
		local defer
		if not model.static[object] then
			defer = true
		end
		if not defer then
			model.static[object].static.foreign[this] = self.super
		else
			if not model.defered[object] then
				model.defered[object] = {}
			end
			table.insert(model.defered[object], function(Model)
				Model.static.foreign[this] = self.super
			end)
		end
	end,

	sql = function(self, field)
		local sql = self.field_name .. " INTEGER"
		if self.unique then
			sql = sql .. " UNIQUE"
		end
		if not self.null then
			sql = sql .. " NOT NULL"
		end
		if self.default then
			sql = sql .. " DEFAULT " .. tostring(self.default)
		end
		return sql
	end
}

function Mopee:initialize(table, fields)
	if not fields.id then 
		fields.id = Mopee.IntegerField({pk = true})
	end
    self.table  = table 
	self.fields = fields
	self.on     = {}
	
		
	for field, validator in pairs(fields) do
		rawset(getmetatable(validator).__index, "field_name", field)
		rawset(getmetatable(validator).__index, "super", self)
	end

end

function Mopee:create_table(callback)

	if false == Mopee.meta.database then
		error('database Not connect')
	end

	local stack  = Array:new()
	local fields = self.fields


	local async = twisted.inline_callbacks(function()
		
		for field, validator in pairs(fields) do
			if(validator.sql)then
				local part = validator:sql(field)
				if not part then 
					error("Cannot Create the DATABASE for model "..self.table.. "'s field "..field) 
				end
				stack:append(part)
			else
				error("Need a sql() function for model "..self.table.. "'s field "..field)
			end
		end
		p(stack)
		local sql = string.format("CREATE TABLE IF NOT EXISTS %s (%s);", self.table, stack:join(',') )

		return sql

	end)

	async(callback)

end


Mopee.meta.database = false


function Mopee.meta.__call(self, args)
	if false == Mopee.meta.database then
		error('database Not connect')
	end
	local data   = {}
	local fields = self.fields
	for field, value in pairs(args) do
		if fields[field] then
			if type(value) == "string" and fields[field].deserialize then
				value = fields[field]:deserialize(value)
				args[field] = value
			end
			local validate =  fields[field](value)
			if validate ~= nil or fields[field].null then
				data[field] = validate
			end
		end
	end
	for field, validator in pairs(fields) do
		if not data[field] then 
			data[field] = validator() 
		end
		
	end

	local ModelInstance = {
		data = data, 
		on = self.on, 
		database = Mopee.meta.database,
		super = self
	}

	local mt = {}
	function mt.__index(self, key)
		return self.data[key]
	end

	function mt.__newindex(self, key, val)
		if fields[key] then
			local val = fields[key](val)
			if val then
				self.data[key] = val
			end
		end
	end

	function mt.__eq(self, other)
		return self.id == other.id
	end

	function mt.__tostring(self)
		if self.super.on.string then
			return self.super.on.string(self)
		end
		return tostring("<%s Instance@%s>"%{self.super.table, self.id or "NaN"})
	end

	function ModelInstance.save(self, callback)
		
		if self.on.save then
			return self.on.save(self, callback)
		end

		local async = twisted.inline_callbacks(function()
			local db = yield(function(cb)
				self.database:connect(cb)
			end)
			
			for field, validator in pairs(fields) do
				if validator.on_save then
					local res = yield(function(cb)
						validator.on_save(self, field, cb)
					end)	
				end

				if not validator.null then
			
					if not self[field] and not validator.pk then
						error("Improper Field: "..field.." failed the validation.")
					end
				end
			end

			--SAVE
			local insert = true
			if self.id then
				insert = false
			end
			local stack = {}
			local fieldstack = {}
			local objectstack = {}
			
			for field, object in pairs(self.data) do
				if fields[field].serialize then
					object = yield(function(cb)
						fields[field]:serialize(object, cb)
					end)
				else
					object = tostring(object)
				end

				table.insert(stack, field.."="..object)
				table.insert(fieldstack, field)
				table.insert(objectstack, object)
			end
		
			local stmt = "UPDATE %s SET %s WHERE id=%s;"
			stmt = stmt:format(self.super.table, table.concat(stack, ","), tostring(self.id))
			if insert then
				stmt = "INSERT INTO %s (%s) VALUES (%s);"
				stmt = stmt:format(self.super.table, table.concat(fieldstack,","), table.concat(objectstack,","))
			end

			return stmt


		end)
		
		async(callback)
		
	end

	setmetatable(ModelInstance, mt)

	return ModelInstance
end

return Mopee
